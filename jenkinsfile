pipeline {
    agent { label params.AGENT_LABEL }

    parameters {
        choice(name: 'AGENT_LABEL', choices: ['user-side-vf2.o-staging', 'user-side-vf2.o-production'], description: 'Select agent to run this build')
        string(name: 'BRANCH_NAME', defaultValue: 'cicd-test', description: 'Branch to build and deploy')
        booleanParam(name: 'BUILD', defaultValue: false, description: 'Set to true to build the branch')
        booleanParam(name: 'DEPLOY', defaultValue: false, description: 'Set to true to deploy after build')
    }

    environment {
        DEPLOY_SERVER = '13.233.129.17'
        DEPLOY_USER = 'ubuntu'
        DEPLOY_PATH = '/var/lib/tomcat10/webapps/'
        GIT_REPO = 'https://github.com/Shradha3001/test-tomcat-project.git'
        GCHAT_WEBHOOK_URL = 'https://chat.googleapis.com/v1/spaces/AAQAQyzaUkw/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=MT5wgI3M3C5aHVpASFZi6h7yi3A0vkl7JFdi4lulEMo'
    }

    stages {
        stage('Who Triggered This Build?') {
            steps {
                script {
                    wrap([$class: 'BuildUser']) {
                        def triggeredBy = env.BUILD_USER ?: "unknown"
                        def triggeredById = env.BUILD_USER_ID ?: "unknown"
                        echo "üë§ This build was manually triggered by: ${triggeredBy} (ID: ${triggeredById})"
                    }
                }
            }
        }

        stage('Checkout Code') {
            steps {
                script {
                    def branch = params.BRANCH_NAME ?: env.BRANCH_NAME
                    echo "Checking out branch: ${branch}"
                    checkout scm: [
                        $class: 'GitSCM',
                        branches: [[name: "*/${branch}"]],
                        userRemoteConfigs: [[url: GIT_REPO]]
                    ]
                    
                    def gitUser = sh(script: "git log -1 --pretty=format:'%an <%ae>'", returnStdout: true).trim()
                    echo "Committer: ${gitUser}"

                    def commitMessage = "üì¶ Code Checkout:\nNew commit by ${gitUser} on branch ${branch}."
                    sendMessageToGoogleChat(commitMessage)
                }
            }
        }

        stage('Notify Build Start') {
            steps {
                script {
                    def commitDetails = sh(script: "git log -1 --pretty=format:'%s|%an'", returnStdout: true).trim()
                    def (commitMessage, committerName) = commitDetails.tokenize('|')

                    // Capture the user who triggered the build
                    def buildUser = env.BUILD_USER_ID ?: "Unknown User"

                    def buildStartMessage = """üöÄ Build Started:
Build Name: ${env.JOB_NAME} [${env.BUILD_NUMBER}]
Build Status: Started
Trigger Commit: ${commitMessage}
Changes Made By: ${committerName}
Build Triggered By: ${buildUser}  // User who triggered the build
Build URL: ${env.BUILD_URL}"""
                    sendMessageToGoogleChat(buildStartMessage)
                }
            }
        }

        stage('Build WAR File') {
            steps {
                script {
                    if (!params.BUILD) {
                        echo "‚ùå BUILD is not checked ‚Äî skipping build."
                        return
                    }

                    echo "Building the WAR file for branch: ${params.BRANCH_NAME}"
                    sh 'mvn clean package -Dmaven.test.skip=true'
                }
            }
        }

        stage('Upload to Elastic Beanstalk') {
            steps {
                script {
                    def warFile = sh(script: "ls target/*.war", returnStdout: true).trim()
                    echo "‚úÖ Uploading WAR file to Elastic Beanstalk: ${warFile}"

                    // Assuming you will pass the Elastic Beanstalk environment URL for each agent
                    def elasticBeanstalkEnvUrl = params.AGENT_LABEL == 'user-side-vf2.o-staging' ? 'http://firebase-staging-env-vf2.eba-di2pahnb.ap-south-1.elasticbeanstalk.com/' : 'https://production.elasticbeanstalk.com'

                    // Get the application name and environment from the URL
                    def applicationName = elasticBeanstalkEnvUrl.split("/")[2]
                    def environmentName = elasticBeanstalkEnvUrl.split("/")[3]

                    // Create application version in Elastic Beanstalk
                    sh """
                    aws elasticbeanstalk create-application-version \
                        --application-name ${applicationName} \
                        --version-label ${env.BUILD_NUMBER} \
                        --source-bundle S3Bucket=vj-ocr-bucket,S3Key=deployments/${warFile} \
                        --region your-region
                    """
                }
            }
        }

        stage('Deploy to Tomcat') {
            steps {
                script {
                    if (!params.DEPLOY) {
                        echo "‚ùå DEPLOY is not checked ‚Äî skipping deployment."
                        return
                    }

                    def warFile = sh(script: "ls target/*.war", returnStdout: true).trim()
                    echo "‚úÖ Deploying WAR file: ${warFile}"

                    sshagent(['ubuntu']) {
                        sh """
                        echo "Copying ${warFile} to Tomcat server"
                        scp -o StrictHostKeyChecking=no ${warFile} ${DEPLOY_USER}@${DEPLOY_SERVER}:${DEPLOY_PATH}/
                        ssh -o StrictHostKeyChecking=no ${DEPLOY_USER}@${DEPLOY_SERVER} 'sudo systemctl restart tomcat10'
                        """
                    }

                    def deploymentStatus = "üöÄ Deployment successful for branch ${params.BRANCH_NAME}."
                    sendMessageToGoogleChat(deploymentStatus)
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }

        success {
            script {
                def successMessage = """‚úÖ Build Success:
Build Name: ${env.JOB_NAME} [${env.BUILD_NUMBER}]
Build Status: Success
Build URL: ${env.BUILD_URL}"""
                sendMessageToGoogleChat(successMessage)
            }
        }

        failure {
            script {
                def failureMessage = """‚ùå Build Failure:
Build Name: ${env.JOB_NAME} [${env.BUILD_NUMBER}]
Build Status: Failure
Build URL: ${env.BUILD_URL}"""
                sendMessageToGoogleChat(failureMessage)
            }
        }
    }
}

def sendMessageToGoogleChat(String message) {
    def payloadGoogleChat = [
        "text": message
    ]
    httpRequest httpMode: 'POST',
                acceptType: 'APPLICATION_JSON',
                contentType: 'APPLICATION_JSON',
                requestBody: groovy.json.JsonOutput.toJson(payloadGoogleChat),
                url: env.GCHAT_WEBHOOK_URL
}
